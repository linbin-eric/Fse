# 序列化方案

[TOC]

## 核心思路

序列化的流程就是从根对象开始，解析其属性，然后序列化输出，如果属性本身也是对象，则继续解析属性，序列化输出，以此类推。

在序列化的过程中，从根对象开始，将每一个对象都加入对象集合，并且给予从1开始的编号。如果后续需要输出的对象已经存在于集合，则只需要输出在集合中的编号即可。通过这种方式，可以实现对循环引用的对象的正确输出。

在序列化的过程中，从根对象开始，对于每一个类，都加入类集合，并且给予从1开始的编号。类集合在初始化的时候会提前放入一些类，并且给予编号，因此序列化开始后，自定义的类的序号是在内建类的编号之后开始递增的。当对象本身被序列化之后，将放入类集合的自定义类的类名按照顺序，输出到序列化值之中。

在序列化的过程中，从根对象开始，每当遇到一个未加入到对象集合的对象时，创建一个针对该类的序列化解析器。该解析器分析类的元数据，主要是属性信息，生成对应的序列化动作内容。并且将解析器保存到上下文中，供后续相同的类进行使用。框架会提前注册一系列内建类的解析器用于执行序列化。

## 序列化格式

从总体上分为四个区间

| 序号 | 长度   | 内容                     |
| ---- | ------ | ------------------------ |
| 1    | 1      | 版本号，当前固定为0xca   |
| 2    | 4      | 序号4的下标偏移量        |
| 3    | 不定长 | 序列化内容体             |
| 4    | 不定长 | 序列化内容体中用到的类名 |

对于区段4而言，采用逗号进行不同类名的分割

## 序列化规则

### 类的规则

| 序号 | 长度            | 内容                                                         |
| ---- | --------------- | ------------------------------------------------------------ |
| 1    | 变长Int编码长度 | 如果对象已经存在于收集器，为对象下标的相反数；否则为类名下标 |
| 2    | 不定长          | 类本身的序列化内容                                           |

对于序号2而言，按照如下规则序列化：

1. 获取该类本身所有的字段，对字段按照名称进行排序
2. 按照步骤1的排序结果，对字段的取值进行序列化输出

#### 字段类型是基本类型和包装类

基本类型按照值输出。

Character,Integer,Byte,Short,Long,Double,Float 使用第一个字节表达是否为null。为null是0，否则是1.非null情况下，接着按照值输出

Boolean 使用0代表null，1代表false，2代表true。

#### 字段类型是String

使用变长int编码输出。如果属性值为null，则输出-1.否则输出字符串长度。非null情况下，顺序输出字符内容。

#### 字段类型是对象

采用可变长int编码输出。如果属性值为null，则输出0。不为null的情况下，按照类的规则输出

#### 字段类型是数组

采用变长int编码输出，如果属性值为null，则输出0.不为null的情况下，按照对象数组的规则输出

### 数组的规则

| 序号 | 长度   | 内容                                                         |
| ---- | ------ | ------------------------------------------------------------ |
| 1    | 1      | 如果数组对象已经存在于收集器，为对象下标的相反数；否则为类名下标 |
| 2    | 不定长 | 类本身的序列化内容                                           |

对于序号2而言，输出规则为：

1. 输出数组长度
2. 按照顺序输出每一个值

#### 元素类型是基本类型或包装类

基本类型情况下，按照值进行输出。

包装类情况下，Character,Integer,Byte,Short,Long,Double,Float 使用第一个字节表达是否为null。为null是0，否则是1.非null情况下，接着按照值输出；Boolean 使用0代表null，1代表false，2代表true。

#### 元素类型是String

使用变长int编码输出。如果元素值为null，则输出-1.否则输出字符串长度。非null情况下，顺序输出字符内容。

#### 元素类型是对象

采用可变长int编码输出。如果元素值为null，则输出0。不为null的情况下，按照类的规则进行输出

## 性能优化

### 缓存类名到类对象的映射

在反序列化时，通过`Class.forName`方法获取类对象消耗很多cpu时间。特别是如果类名指向的是数组的情况。因此在内部使用一个Map将两者的关系缓存起来，后续操作只需要查询即可。

### 类属性类型为final时，不执行注册

当类的属性的类型为final时，通过类的元数据信息就可以找到该属性的类信息，因此无需注册到上下文中。并且在分析元数据的时候就可以直接获取该属性的序列化器。此时，不注册有两个好处

1. 提前固定序列化器，无需在序列化时查找
2. 减少向上下文注册的类型信息

需要注意，由于不执行注册，因此序列化和反序列化都需要执行单独的方法，区分于执行注册的情况。